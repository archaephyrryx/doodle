use std::str::FromStr;
use num_bigint::BigInt;
use analytic_engine::core::{TypedConst, BasicBinOp, BinOp, BasicUnaryOp, UnaryOp, Expr, NumRep};

grammar;

pub Tree: Expr = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")]
    <op:Op0> <t:Tree> => Expr::UnaryOp(op, Box::new(t)),
    #[precedence(level="2")]
    <t:Tree> "as" <r:Rep> => Expr::Cast(r, Box::new(t)),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Tree> <op:Op1> <r:Tree> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    #[precedence(level="4")] #[assoc(side="left")]
    <l:Tree> <op:Op2> <r:Tree> => Expr::BinOp(op, Box::new(l), Box::new(r)),
}

Term: Expr = {
    Const => Expr::Const(<>),
    "(" <Tree> ")",
}

OpCode0: BasicUnaryOp = {
    "~" => BasicUnaryOp::Negate,
    "abs" => BasicUnaryOp::AbsVal,
}

OpCode1: BasicBinOp = {
    "*" => BasicBinOp::Mul,
    "/" => BasicBinOp::Div,
    "%" => BasicBinOp::Rem,
}

OpCode2: BasicBinOp = {
    "+" => BasicBinOp::Add,
    "-" => BasicBinOp::Sub,
}

Op0: UnaryOp = {
    <op:OpCode0> <r:Rep> => UnaryOp::new(op, Some(r)),
    <op:OpCode0> => UnaryOp::new(op, None),
}

Op1: BinOp = {
    <op:OpCode1> <r:Rep> => BinOp::new(op, Some(r)),
    <op:OpCode1> => BinOp::new(op, None),
}

Op2: BinOp = {
    <op:OpCode2> <r:Rep> => BinOp::new(op, Some(r)),
    <op:OpCode2> => BinOp::new(op, None),
}

Const: TypedConst = {
    <n:Num> => TypedConst(n, NumRep::AUTO),
    <n:Num><r:Rep> => TypedConst(n, r),
}

Rep: NumRep = {
    "u8" => NumRep::U8,
    "u16" => NumRep::U16,
    "u32" => NumRep::U32,
    "u64" => NumRep::U64,
    "i8" => NumRep::I8,
    "i16" => NumRep::I16,
    "i32" => NumRep::I32,
    "i64" => NumRep::I64,
}

Num: BigInt = <s:r"-?[0-9]+"> => BigInt::from_str(s).unwrap();
